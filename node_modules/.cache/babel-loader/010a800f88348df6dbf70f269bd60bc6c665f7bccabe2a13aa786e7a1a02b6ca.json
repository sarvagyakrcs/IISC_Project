{"ast":null,"code":"/*! @azure/msal-common v14.5.0 2023-12-01 */\n'use strict';\n\nimport { extractTokenClaims } from '../../account/AuthToken.mjs';\nimport { createClientAuthError } from '../../error/ClientAuthError.mjs';\nimport { Separators, CredentialType, AuthenticationScheme, SERVER_TELEM_CONSTANTS } from '../../utils/Constants.mjs';\nimport { TimeUtils } from '../../utils/TimeUtils.mjs';\nimport { tokenClaimsCnfRequiredForSignedJwt } from '../../error/ClientAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Cache Key: <home_account_id>-<environment>-<credential_type>-<client_id or familyId>-<realm>-<scopes>-<claims hash>-<scheme>\n * IdToken Example: uid.utid-login.microsoftonline.com-idtoken-app_client_id-contoso.com\n * AccessToken Example: uid.utid-login.microsoftonline.com-accesstoken-app_client_id-contoso.com-scope1 scope2--pop\n * RefreshToken Example: uid.utid-login.microsoftonline.com-refreshtoken-1-contoso.com\n * @param credentialEntity\n * @returns\n */\nfunction generateCredentialKey(credentialEntity) {\n  const credentialKey = [generateAccountId(credentialEntity), generateCredentialId(credentialEntity), generateTarget(credentialEntity), generateClaimsHash(credentialEntity), generateScheme(credentialEntity)];\n  return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n}\n/**\n * Create IdTokenEntity\n * @param homeAccountId\n * @param authenticationResult\n * @param clientId\n * @param authority\n */\nfunction createIdTokenEntity(homeAccountId, environment, idToken, clientId, tenantId) {\n  const idTokenEntity = {\n    credentialType: CredentialType.ID_TOKEN,\n    homeAccountId: homeAccountId,\n    environment: environment,\n    clientId: clientId,\n    secret: idToken,\n    realm: tenantId\n  };\n  return idTokenEntity;\n}\n/**\n * Create AccessTokenEntity\n * @param homeAccountId\n * @param environment\n * @param accessToken\n * @param clientId\n * @param tenantId\n * @param scopes\n * @param expiresOn\n * @param extExpiresOn\n */\nfunction createAccessTokenEntity(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, base64Decode, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {\n  const atEntity = {\n    homeAccountId: homeAccountId,\n    credentialType: CredentialType.ACCESS_TOKEN,\n    secret: accessToken,\n    cachedAt: TimeUtils.nowSeconds().toString(),\n    expiresOn: expiresOn.toString(),\n    extendedExpiresOn: extExpiresOn.toString(),\n    environment: environment,\n    clientId: clientId,\n    realm: tenantId,\n    target: scopes,\n    tokenType: tokenType || AuthenticationScheme.BEARER\n  };\n  if (userAssertionHash) {\n    atEntity.userAssertionHash = userAssertionHash;\n  }\n  if (refreshOn) {\n    atEntity.refreshOn = refreshOn.toString();\n  }\n  if (requestedClaims) {\n    atEntity.requestedClaims = requestedClaims;\n    atEntity.requestedClaimsHash = requestedClaimsHash;\n  }\n  /*\n   * Create Access Token With Auth Scheme instead of regular access token\n   * Cast to lower to handle \"bearer\" from ADFS\n   */\n  if (atEntity.tokenType?.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) {\n    atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n    switch (atEntity.tokenType) {\n      case AuthenticationScheme.POP:\n        // Make sure keyId is present and add it to credential\n        const tokenClaims = extractTokenClaims(accessToken, base64Decode);\n        if (!tokenClaims?.cnf?.kid) {\n          throw createClientAuthError(tokenClaimsCnfRequiredForSignedJwt);\n        }\n        atEntity.keyId = tokenClaims.cnf.kid;\n        break;\n      case AuthenticationScheme.SSH:\n        atEntity.keyId = keyId;\n    }\n  }\n  return atEntity;\n}\n/**\n * Create RefreshTokenEntity\n * @param homeAccountId\n * @param authenticationResult\n * @param clientId\n * @param authority\n */\nfunction createRefreshTokenEntity(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash) {\n  const rtEntity = {\n    credentialType: CredentialType.REFRESH_TOKEN,\n    homeAccountId: homeAccountId,\n    environment: environment,\n    clientId: clientId,\n    secret: refreshToken\n  };\n  if (userAssertionHash) {\n    rtEntity.userAssertionHash = userAssertionHash;\n  }\n  if (familyId) {\n    rtEntity.familyId = familyId;\n  }\n  return rtEntity;\n}\nfunction isCredentialEntity(entity) {\n  return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"credentialType\") && entity.hasOwnProperty(\"clientId\") && entity.hasOwnProperty(\"secret\");\n}\n/**\n * Validates an entity: checks for all expected params\n * @param entity\n */\nfunction isAccessTokenEntity(entity) {\n  if (!entity) {\n    return false;\n  }\n  return isCredentialEntity(entity) && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"target\") && (entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN || entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\n}\n/**\n * Validates an entity: checks for all expected params\n * @param entity\n */\nfunction isIdTokenEntity(entity) {\n  if (!entity) {\n    return false;\n  }\n  return isCredentialEntity(entity) && entity.hasOwnProperty(\"realm\") && entity[\"credentialType\"] === CredentialType.ID_TOKEN;\n}\n/**\n * Validates an entity: checks for all expected params\n * @param entity\n */\nfunction isRefreshTokenEntity(entity) {\n  if (!entity) {\n    return false;\n  }\n  return isCredentialEntity(entity) && entity[\"credentialType\"] === CredentialType.REFRESH_TOKEN;\n}\n/**\n * Generate Account Id key component as per the schema: <home_account_id>-<environment>\n */\nfunction generateAccountId(credentialEntity) {\n  const accountId = [credentialEntity.homeAccountId, credentialEntity.environment];\n  return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n}\n/**\n * Generate Credential Id key component as per the schema: <credential_type>-<client_id>-<realm>\n */\nfunction generateCredentialId(credentialEntity) {\n  const clientOrFamilyId = credentialEntity.credentialType === CredentialType.REFRESH_TOKEN ? credentialEntity.familyId || credentialEntity.clientId : credentialEntity.clientId;\n  const credentialId = [credentialEntity.credentialType, clientOrFamilyId, credentialEntity.realm || \"\"];\n  return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n}\n/**\n * Generate target key component as per schema: <target>\n */\nfunction generateTarget(credentialEntity) {\n  return (credentialEntity.target || \"\").toLowerCase();\n}\n/**\n * Generate requested claims key component as per schema: <requestedClaims>\n */\nfunction generateClaimsHash(credentialEntity) {\n  return (credentialEntity.requestedClaimsHash || \"\").toLowerCase();\n}\n/**\n * Generate scheme key componenet as per schema: <scheme>\n */\nfunction generateScheme(credentialEntity) {\n  /*\n   * PoP Tokens and SSH certs include scheme in cache key\n   * Cast to lowercase to handle \"bearer\" from ADFS\n   */\n  return credentialEntity.tokenType && credentialEntity.tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? credentialEntity.tokenType.toLowerCase() : \"\";\n}\n/**\n * validates if a given cache entry is \"Telemetry\", parses <key,value>\n * @param key\n * @param entity\n */\nfunction isServerTelemetryEntity(key, entity) {\n  const validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;\n  let validateEntity = true;\n  if (entity) {\n    validateEntity = entity.hasOwnProperty(\"failedRequests\") && entity.hasOwnProperty(\"errors\") && entity.hasOwnProperty(\"cacheHits\");\n  }\n  return validateKey && validateEntity;\n}\nexport { createAccessTokenEntity, createIdTokenEntity, createRefreshTokenEntity, generateCredentialKey, isAccessTokenEntity, isCredentialEntity, isIdTokenEntity, isRefreshTokenEntity, isServerTelemetryEntity };","map":{"version":3,"names":["generateCredentialKey","credentialEntity","credentialKey","generateAccountId","generateCredentialId","generateTarget","generateClaimsHash","generateScheme","join","Separators","CACHE_KEY_SEPARATOR","toLowerCase","createIdTokenEntity","homeAccountId","environment","idToken","clientId","tenantId","idTokenEntity","credentialType","CredentialType","ID_TOKEN","secret","realm","createAccessTokenEntity","accessToken","scopes","expiresOn","extExpiresOn","base64Decode","refreshOn","tokenType","userAssertionHash","keyId","requestedClaims","requestedClaimsHash","atEntity","ACCESS_TOKEN","cachedAt","TimeUtils","nowSeconds","toString","extendedExpiresOn","target","AuthenticationScheme","BEARER","ACCESS_TOKEN_WITH_AUTH_SCHEME","POP","tokenClaims","extractTokenClaims","cnf","kid","createClientAuthError","tokenClaimsCnfRequiredForSignedJwt","SSH","createRefreshTokenEntity","refreshToken","familyId","rtEntity","REFRESH_TOKEN","isCredentialEntity","entity","hasOwnProperty","isAccessTokenEntity","isIdTokenEntity","isRefreshTokenEntity","accountId","clientOrFamilyId","credentialId","isServerTelemetryEntity","key","validateKey","indexOf","SERVER_TELEM_CONSTANTS","CACHE_KEY","validateEntity"],"sources":["/Users/sarvagyakumar/Desktop/IISC_Project/node_modules/@azure/msal-common/src/cache/utils/CacheHelpers.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { extractTokenClaims } from \"../../account/AuthToken\";\nimport { TokenClaims } from \"../../account/TokenClaims\";\nimport {\n    ClientAuthErrorCodes,\n    createClientAuthError,\n} from \"../../error/ClientAuthError\";\nimport {\n    AuthenticationScheme,\n    CredentialType,\n    SERVER_TELEM_CONSTANTS,\n    Separators,\n} from \"../../utils/Constants\";\nimport { TimeUtils } from \"../../utils/TimeUtils\";\nimport { AccessTokenEntity } from \"../entities/AccessTokenEntity\";\nimport { CredentialEntity } from \"../entities/CredentialEntity\";\nimport { IdTokenEntity } from \"../entities/IdTokenEntity\";\nimport { RefreshTokenEntity } from \"../entities/RefreshTokenEntity\";\n\n/**\n * Cache Key: <home_account_id>-<environment>-<credential_type>-<client_id or familyId>-<realm>-<scopes>-<claims hash>-<scheme>\n * IdToken Example: uid.utid-login.microsoftonline.com-idtoken-app_client_id-contoso.com\n * AccessToken Example: uid.utid-login.microsoftonline.com-accesstoken-app_client_id-contoso.com-scope1 scope2--pop\n * RefreshToken Example: uid.utid-login.microsoftonline.com-refreshtoken-1-contoso.com\n * @param credentialEntity\n * @returns\n */\nexport function generateCredentialKey(\n    credentialEntity: CredentialEntity\n): string {\n    const credentialKey = [\n        generateAccountId(credentialEntity),\n        generateCredentialId(credentialEntity),\n        generateTarget(credentialEntity),\n        generateClaimsHash(credentialEntity),\n        generateScheme(credentialEntity),\n    ];\n\n    return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n}\n\n/**\n * Create IdTokenEntity\n * @param homeAccountId\n * @param authenticationResult\n * @param clientId\n * @param authority\n */\nexport function createIdTokenEntity(\n    homeAccountId: string,\n    environment: string,\n    idToken: string,\n    clientId: string,\n    tenantId: string\n): IdTokenEntity {\n    const idTokenEntity: IdTokenEntity = {\n        credentialType: CredentialType.ID_TOKEN,\n        homeAccountId: homeAccountId,\n        environment: environment,\n        clientId: clientId,\n        secret: idToken,\n        realm: tenantId,\n    };\n\n    return idTokenEntity;\n}\n\n/**\n * Create AccessTokenEntity\n * @param homeAccountId\n * @param environment\n * @param accessToken\n * @param clientId\n * @param tenantId\n * @param scopes\n * @param expiresOn\n * @param extExpiresOn\n */\nexport function createAccessTokenEntity(\n    homeAccountId: string,\n    environment: string,\n    accessToken: string,\n    clientId: string,\n    tenantId: string,\n    scopes: string,\n    expiresOn: number,\n    extExpiresOn: number,\n    base64Decode: (input: string) => string,\n    refreshOn?: number,\n    tokenType?: AuthenticationScheme,\n    userAssertionHash?: string,\n    keyId?: string,\n    requestedClaims?: string,\n    requestedClaimsHash?: string\n): AccessTokenEntity {\n    const atEntity: AccessTokenEntity = {\n        homeAccountId: homeAccountId,\n        credentialType: CredentialType.ACCESS_TOKEN,\n        secret: accessToken,\n        cachedAt: TimeUtils.nowSeconds().toString(),\n        expiresOn: expiresOn.toString(),\n        extendedExpiresOn: extExpiresOn.toString(),\n        environment: environment,\n        clientId: clientId,\n        realm: tenantId,\n        target: scopes,\n        tokenType: tokenType || AuthenticationScheme.BEARER,\n    };\n\n    if (userAssertionHash) {\n        atEntity.userAssertionHash = userAssertionHash;\n    }\n\n    if (refreshOn) {\n        atEntity.refreshOn = refreshOn.toString();\n    }\n\n    if (requestedClaims) {\n        atEntity.requestedClaims = requestedClaims;\n        atEntity.requestedClaimsHash = requestedClaimsHash;\n    }\n\n    /*\n     * Create Access Token With Auth Scheme instead of regular access token\n     * Cast to lower to handle \"bearer\" from ADFS\n     */\n    if (\n        atEntity.tokenType?.toLowerCase() !==\n        AuthenticationScheme.BEARER.toLowerCase()\n    ) {\n        atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n        switch (atEntity.tokenType) {\n            case AuthenticationScheme.POP:\n                // Make sure keyId is present and add it to credential\n                const tokenClaims: TokenClaims | null = extractTokenClaims(\n                    accessToken,\n                    base64Decode\n                );\n                if (!tokenClaims?.cnf?.kid) {\n                    throw createClientAuthError(\n                        ClientAuthErrorCodes.tokenClaimsCnfRequiredForSignedJwt\n                    );\n                }\n                atEntity.keyId = tokenClaims.cnf.kid;\n                break;\n            case AuthenticationScheme.SSH:\n                atEntity.keyId = keyId;\n        }\n    }\n\n    return atEntity;\n}\n\n/**\n * Create RefreshTokenEntity\n * @param homeAccountId\n * @param authenticationResult\n * @param clientId\n * @param authority\n */\nexport function createRefreshTokenEntity(\n    homeAccountId: string,\n    environment: string,\n    refreshToken: string,\n    clientId: string,\n    familyId?: string,\n    userAssertionHash?: string\n): RefreshTokenEntity {\n    const rtEntity: RefreshTokenEntity = {\n        credentialType: CredentialType.REFRESH_TOKEN,\n        homeAccountId: homeAccountId,\n        environment: environment,\n        clientId: clientId,\n        secret: refreshToken,\n    };\n\n    if (userAssertionHash) {\n        rtEntity.userAssertionHash = userAssertionHash;\n    }\n\n    if (familyId) {\n        rtEntity.familyId = familyId;\n    }\n\n    return rtEntity;\n}\n\nexport function isCredentialEntity(entity: object): boolean {\n    return (\n        entity.hasOwnProperty(\"homeAccountId\") &&\n        entity.hasOwnProperty(\"environment\") &&\n        entity.hasOwnProperty(\"credentialType\") &&\n        entity.hasOwnProperty(\"clientId\") &&\n        entity.hasOwnProperty(\"secret\")\n    );\n}\n\n/**\n * Validates an entity: checks for all expected params\n * @param entity\n */\nexport function isAccessTokenEntity(entity: object): boolean {\n    if (!entity) {\n        return false;\n    }\n\n    return (\n        isCredentialEntity(entity) &&\n        entity.hasOwnProperty(\"realm\") &&\n        entity.hasOwnProperty(\"target\") &&\n        (entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN ||\n            entity[\"credentialType\"] ===\n                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME)\n    );\n}\n\n/**\n * Validates an entity: checks for all expected params\n * @param entity\n */\nexport function isIdTokenEntity(entity: object): boolean {\n    if (!entity) {\n        return false;\n    }\n\n    return (\n        isCredentialEntity(entity) &&\n        entity.hasOwnProperty(\"realm\") &&\n        entity[\"credentialType\"] === CredentialType.ID_TOKEN\n    );\n}\n\n/**\n * Validates an entity: checks for all expected params\n * @param entity\n */\nexport function isRefreshTokenEntity(entity: object): boolean {\n    if (!entity) {\n        return false;\n    }\n\n    return (\n        isCredentialEntity(entity) &&\n        entity[\"credentialType\"] === CredentialType.REFRESH_TOKEN\n    );\n}\n\n/**\n * Generate Account Id key component as per the schema: <home_account_id>-<environment>\n */\nfunction generateAccountId(credentialEntity: CredentialEntity): string {\n    const accountId: Array<string> = [\n        credentialEntity.homeAccountId,\n        credentialEntity.environment,\n    ];\n    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n}\n\n/**\n * Generate Credential Id key component as per the schema: <credential_type>-<client_id>-<realm>\n */\nfunction generateCredentialId(credentialEntity: CredentialEntity): string {\n    const clientOrFamilyId =\n        credentialEntity.credentialType === CredentialType.REFRESH_TOKEN\n            ? credentialEntity.familyId || credentialEntity.clientId\n            : credentialEntity.clientId;\n    const credentialId: Array<string> = [\n        credentialEntity.credentialType,\n        clientOrFamilyId,\n        credentialEntity.realm || \"\",\n    ];\n\n    return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n}\n\n/**\n * Generate target key component as per schema: <target>\n */\nfunction generateTarget(credentialEntity: CredentialEntity): string {\n    return (credentialEntity.target || \"\").toLowerCase();\n}\n\n/**\n * Generate requested claims key component as per schema: <requestedClaims>\n */\nfunction generateClaimsHash(credentialEntity: CredentialEntity): string {\n    return (credentialEntity.requestedClaimsHash || \"\").toLowerCase();\n}\n\n/**\n * Generate scheme key componenet as per schema: <scheme>\n */\nfunction generateScheme(credentialEntity: CredentialEntity): string {\n    /*\n     * PoP Tokens and SSH certs include scheme in cache key\n     * Cast to lowercase to handle \"bearer\" from ADFS\n     */\n    return credentialEntity.tokenType &&\n        credentialEntity.tokenType.toLowerCase() !==\n            AuthenticationScheme.BEARER.toLowerCase()\n        ? credentialEntity.tokenType.toLowerCase()\n        : \"\";\n}\n\n/**\n * validates if a given cache entry is \"Telemetry\", parses <key,value>\n * @param key\n * @param entity\n */\nexport function isServerTelemetryEntity(key: string, entity?: object): boolean {\n    const validateKey: boolean =\n        key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;\n    let validateEntity: boolean = true;\n\n    if (entity) {\n        validateEntity =\n            entity.hasOwnProperty(\"failedRequests\") &&\n            entity.hasOwnProperty(\"errors\") &&\n            entity.hasOwnProperty(\"cacheHits\");\n    }\n\n    return validateKey && validateEntity;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}