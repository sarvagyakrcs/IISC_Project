{"ast":null,"code":"/*! @azure/msal-common v14.5.0 2023-12-01 */\n'use strict';\n\nimport { IntFields, PerformanceEventStatus } from './PerformanceEvent.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass PerformanceClient {\n  /**\n   * Creates an instance of PerformanceClient,\n   * an abstract class containing core performance telemetry logic.\n   *\n   * @constructor\n   * @param {string} clientId Client ID of the application\n   * @param {string} authority Authority used by the application\n   * @param {Logger} logger Logger used by the application\n   * @param {string} libraryName Name of the library\n   * @param {string} libraryVersion Version of the library\n   * @param {ApplicationTelemetry} applicationTelemetry application name and version\n   * @param {Set<String>} intFields integer fields to be truncated\n   */\n  constructor(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry, intFields) {\n    this.authority = authority;\n    this.libraryName = libraryName;\n    this.libraryVersion = libraryVersion;\n    this.applicationTelemetry = applicationTelemetry;\n    this.clientId = clientId;\n    this.logger = logger;\n    this.callbacks = new Map();\n    this.eventsByCorrelationId = new Map();\n    this.queueMeasurements = new Map();\n    this.preQueueTimeByCorrelationId = new Map();\n    this.intFields = intFields || new Set();\n    for (const item of IntFields) {\n      this.intFields.add(item);\n    }\n  }\n  /**\n   * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\n   * Note: this function can be changed to abstract at the next major version bump.\n   *\n   * @param {string} measureName\n   * @param {string} correlationId\n   * @returns {IPerformanceMeasurement}\n   */\n  startPerformanceMeasurement(measureName,\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  correlationId // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    return {};\n  }\n  /**\n   * Gets map of pre-queue times by correlation Id\n   *\n   * @param {PerformanceEvents} eventName\n   * @param {string} correlationId\n   * @returns {number}\n   */\n  getPreQueueTime(eventName, correlationId) {\n    const preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);\n    if (!preQueueEvent) {\n      this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: ${correlationId}, unable to add queue measurement`);\n      return;\n    } else if (preQueueEvent.name !== eventName) {\n      this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue time found for ${eventName}, unable to add queue measurement`);\n      return;\n    }\n    return preQueueEvent.time;\n  }\n  /**\n   * Calculates the difference between current time and time when function was queued.\n   * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.\n   *\n   * @param {number} preQueueTime\n   * @param {number} currentTime\n   * @returns {number}\n   */\n  calculateQueuedTime(preQueueTime, currentTime) {\n    if (preQueueTime < 1) {\n      this.logger.trace(`PerformanceClient: preQueueTime should be a positive integer and not ${preQueueTime}`);\n      return 0;\n    }\n    if (currentTime < 1) {\n      this.logger.trace(`PerformanceClient: currentTime should be a positive integer and not ${currentTime}`);\n      return 0;\n    }\n    if (currentTime < preQueueTime) {\n      this.logger.trace(\"PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved\");\n      return 0;\n    }\n    return currentTime - preQueueTime;\n  }\n  /**\n   * Adds queue measurement time to QueueMeasurements array for given correlation ID.\n   *\n   * @param {PerformanceEvents} eventName\n   * @param {?string} correlationId\n   * @param {?number} queueTime\n   * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\n   * @returns\n   */\n  addQueueMeasurement(eventName, correlationId, queueTime, manuallyCompleted) {\n    if (!correlationId) {\n      this.logger.trace(`PerformanceClient.addQueueMeasurement: correlationId not provided for ${eventName}, cannot add queue measurement`);\n      return;\n    }\n    if (queueTime === 0) {\n      // Possible for there to be no queue time after calculation\n      this.logger.trace(`PerformanceClient.addQueueMeasurement: queue time provided for ${eventName} is ${queueTime}`);\n    } else if (!queueTime) {\n      this.logger.trace(`PerformanceClient.addQueueMeasurement: no queue time provided for ${eventName}`);\n      return;\n    }\n    const queueMeasurement = {\n      eventName,\n      // Always default queue time to 0 for manually completed (improperly instrumented)\n      queueTime: manuallyCompleted ? 0 : queueTime,\n      manuallyCompleted\n    };\n    // Adds to existing correlation Id if present in queueMeasurements\n    const existingMeasurements = this.queueMeasurements.get(correlationId);\n    if (existingMeasurements) {\n      existingMeasurements.push(queueMeasurement);\n      this.queueMeasurements.set(correlationId, existingMeasurements);\n    } else {\n      // Sets new correlation Id if not present in queueMeasurements\n      this.logger.trace(`PerformanceClient.addQueueMeasurement: adding correlationId ${correlationId} to queue measurements`);\n      const measurementArray = [queueMeasurement];\n      this.queueMeasurements.set(correlationId, measurementArray);\n    }\n    // Delete processed pre-queue event.\n    this.preQueueTimeByCorrelationId.delete(correlationId);\n  }\n  /**\n   * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\n   *\n   * @param {PerformanceEvents} measureName\n   * @param {?string} [correlationId]\n   * @returns {InProgressPerformanceEvent}\n   */\n  startMeasurement(measureName, correlationId) {\n    // Generate a placeholder correlation if the request does not provide one\n    const eventCorrelationId = correlationId || this.generateId();\n    if (!correlationId) {\n      this.logger.info(`PerformanceClient: No correlation id provided for ${measureName}, generating`, eventCorrelationId);\n    }\n    this.logger.trace(`PerformanceClient: Performance measurement started for ${measureName}`, eventCorrelationId);\n    const performanceMeasurement = this.startPerformanceMeasurement(measureName, eventCorrelationId);\n    performanceMeasurement.startMeasurement();\n    const inProgressEvent = {\n      eventId: this.generateId(),\n      status: PerformanceEventStatus.InProgress,\n      authority: this.authority,\n      libraryName: this.libraryName,\n      libraryVersion: this.libraryVersion,\n      clientId: this.clientId,\n      name: measureName,\n      startTimeMs: Date.now(),\n      correlationId: eventCorrelationId,\n      appName: this.applicationTelemetry?.appName,\n      appVersion: this.applicationTelemetry?.appVersion\n    };\n    // Store in progress events so they can be discarded if not ended properly\n    this.cacheEventByCorrelationId(inProgressEvent);\n    // Return the event and functions the caller can use to properly end/flush the measurement\n    return {\n      end: event => {\n        return this.endMeasurement({\n          // Initial set of event properties\n          ...inProgressEvent,\n          // Properties set when event ends\n          ...event\n        }, performanceMeasurement);\n      },\n      discard: () => {\n        return this.discardMeasurements(inProgressEvent.correlationId);\n      },\n      add: fields => {\n        return this.addFields(fields, inProgressEvent.correlationId);\n      },\n      increment: fields => {\n        return this.incrementFields(fields, inProgressEvent.correlationId);\n      },\n      measurement: performanceMeasurement,\n      event: inProgressEvent\n    };\n  }\n  /**\n   * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\n   * as consumers should instead use the function returned by startMeasurement.\n   * Adds a new field named as \"[event name]DurationMs\" for sub-measurements, completes and emits an event\n   * otherwise.\n   *\n   * @param {PerformanceEvent} event\n   * @param {IPerformanceMeasurement} measurement\n   * @returns {(PerformanceEvent | null)}\n   */\n  endMeasurement(event, measurement) {\n    const rootEvent = this.eventsByCorrelationId.get(event.correlationId);\n    if (!rootEvent) {\n      this.logger.trace(`PerformanceClient: Measurement not found for ${event.eventId}`, event.correlationId);\n      return null;\n    }\n    const isRoot = event.eventId === rootEvent.eventId;\n    let queueInfo = {\n      totalQueueTime: 0,\n      totalQueueCount: 0,\n      manuallyCompletedCount: 0\n    };\n    if (isRoot) {\n      queueInfo = this.getQueueInfo(event.correlationId);\n      this.discardCache(rootEvent.correlationId);\n    } else {\n      rootEvent.incompleteSubMeasurements?.delete(event.eventId);\n    }\n    measurement?.endMeasurement();\n    const durationMs = measurement?.flushMeasurement();\n    // null indicates no measurement was taken (e.g. needed performance APIs not present)\n    if (!durationMs) {\n      this.logger.trace(\"PerformanceClient: Performance measurement not taken\", rootEvent.correlationId);\n      return null;\n    }\n    this.logger.trace(`PerformanceClient: Performance measurement ended for ${event.name}: ${durationMs} ms`, event.correlationId);\n    // Add sub-measurement attribute to root event.\n    if (!isRoot) {\n      rootEvent[event.name + \"DurationMs\"] = Math.floor(durationMs);\n      return {\n        ...rootEvent\n      };\n    }\n    let finalEvent = {\n      ...rootEvent,\n      ...event\n    };\n    let incompleteSubsCount = 0;\n    // Incomplete sub-measurements are discarded. They are likely an instrumentation bug that should be fixed.\n    finalEvent.incompleteSubMeasurements?.forEach(subMeasurement => {\n      this.logger.trace(`PerformanceClient: Incomplete submeasurement ${subMeasurement.name} found for ${event.name}`, finalEvent.correlationId);\n      incompleteSubsCount++;\n    });\n    finalEvent.incompleteSubMeasurements = undefined;\n    finalEvent = {\n      ...finalEvent,\n      durationMs: Math.round(durationMs),\n      queuedTimeMs: queueInfo.totalQueueTime,\n      queuedCount: queueInfo.totalQueueCount,\n      queuedManuallyCompletedCount: queueInfo.manuallyCompletedCount,\n      status: PerformanceEventStatus.Completed,\n      incompleteSubsCount\n    };\n    this.truncateIntegralFields(finalEvent);\n    this.emitEvents([finalEvent], event.correlationId);\n    return finalEvent;\n  }\n  /**\n   * Saves extra information to be emitted when the measurements are flushed\n   * @param fields\n   * @param correlationId\n   */\n  addFields(fields, correlationId) {\n    this.logger.trace(\"PerformanceClient: Updating static fields\");\n    const event = this.eventsByCorrelationId.get(correlationId);\n    if (event) {\n      this.eventsByCorrelationId.set(correlationId, {\n        ...event,\n        ...fields\n      });\n    } else {\n      this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\n    }\n  }\n  /**\n   * Increment counters to be emitted when the measurements are flushed\n   * @param fields {string[]}\n   * @param correlationId {string} correlation identifier\n   */\n  incrementFields(fields, correlationId) {\n    this.logger.trace(\"PerformanceClient: Updating counters\");\n    const event = this.eventsByCorrelationId.get(correlationId);\n    if (event) {\n      for (const counter in fields) {\n        if (!event.hasOwnProperty(counter)) {\n          event[counter] = 0;\n        } else if (isNaN(Number(event[counter]))) {\n          return;\n        }\n        event[counter] += fields[counter];\n      }\n    } else {\n      this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\n    }\n  }\n  /**\n   * Upserts event into event cache.\n   * First key is the correlation id, second key is the event id.\n   * Allows for events to be grouped by correlation id,\n   * and to easily allow for properties on them to be updated.\n   *\n   * @private\n   * @param {PerformanceEvent} event\n   */\n  cacheEventByCorrelationId(event) {\n    const rootEvent = this.eventsByCorrelationId.get(event.correlationId);\n    if (rootEvent) {\n      this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} added/updated`, event.correlationId);\n      rootEvent.incompleteSubMeasurements = rootEvent.incompleteSubMeasurements || new Map();\n      rootEvent.incompleteSubMeasurements.set(event.eventId, {\n        name: event.name,\n        startTimeMs: event.startTimeMs\n      });\n    } else {\n      this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} started`, event.correlationId);\n      this.eventsByCorrelationId.set(event.correlationId, {\n        ...event\n      });\n    }\n  }\n  getQueueInfo(correlationId) {\n    const queueMeasurementForCorrelationId = this.queueMeasurements.get(correlationId);\n    if (!queueMeasurementForCorrelationId) {\n      this.logger.trace(`PerformanceClient: no queue measurements found for for correlationId: ${correlationId}`);\n    }\n    let totalQueueTime = 0;\n    let totalQueueCount = 0;\n    let manuallyCompletedCount = 0;\n    queueMeasurementForCorrelationId?.forEach(measurement => {\n      totalQueueTime += measurement.queueTime;\n      totalQueueCount++;\n      manuallyCompletedCount += measurement.manuallyCompleted ? 1 : 0;\n    });\n    return {\n      totalQueueTime,\n      totalQueueCount,\n      manuallyCompletedCount\n    };\n  }\n  /**\n   * Removes measurements for a given correlation id.\n   *\n   * @param {string} correlationId\n   */\n  discardMeasurements(correlationId) {\n    this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\n    this.eventsByCorrelationId.delete(correlationId);\n  }\n  /**\n   * Removes cache for a given correlation id.\n   *\n   * @param {string} correlationId correlation identifier\n   */\n  discardCache(correlationId) {\n    this.discardMeasurements(correlationId);\n    this.logger.trace(\"PerformanceClient: QueueMeasurements discarded\", correlationId);\n    this.queueMeasurements.delete(correlationId);\n    this.logger.trace(\"PerformanceClient: Pre-queue times discarded\", correlationId);\n    this.preQueueTimeByCorrelationId.delete(correlationId);\n  }\n  /**\n   * Registers a callback function to receive performance events.\n   *\n   * @param {PerformanceCallbackFunction} callback\n   * @returns {string}\n   */\n  addPerformanceCallback(callback) {\n    const callbackId = this.generateId();\n    this.callbacks.set(callbackId, callback);\n    this.logger.verbose(`PerformanceClient: Performance callback registered with id: ${callbackId}`);\n    return callbackId;\n  }\n  /**\n   * Removes a callback registered with addPerformanceCallback.\n   *\n   * @param {string} callbackId\n   * @returns {boolean}\n   */\n  removePerformanceCallback(callbackId) {\n    const result = this.callbacks.delete(callbackId);\n    if (result) {\n      this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} removed.`);\n    } else {\n      this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} not removed.`);\n    }\n    return result;\n  }\n  /**\n   * Emits events to all registered callbacks.\n   *\n   * @param {PerformanceEvent[]} events\n   * @param {?string} [correlationId]\n   */\n  emitEvents(events, correlationId) {\n    this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\n    this.callbacks.forEach((callback, callbackId) => {\n      this.logger.trace(`PerformanceClient: Emitting event to callback ${callbackId}`, correlationId);\n      callback.apply(null, [events]);\n    });\n  }\n  /**\n   * Enforce truncation of integral fields in performance event.\n   * @param {PerformanceEvent} event performance event to update.\n   * @param {Set<string>} intFields integral fields.\n   */\n  truncateIntegralFields(event) {\n    this.intFields.forEach(key => {\n      if (key in event && typeof event[key] === \"number\") {\n        event[key] = Math.floor(event[key]);\n      }\n    });\n  }\n}\nexport { PerformanceClient };","map":{"version":3,"names":["PerformanceClient","constructor","clientId","authority","logger","libraryName","libraryVersion","applicationTelemetry","intFields","callbacks","Map","eventsByCorrelationId","queueMeasurements","preQueueTimeByCorrelationId","Set","item","IntFields","add","startPerformanceMeasurement","measureName","correlationId","getPreQueueTime","eventName","preQueueEvent","get","trace","name","time","calculateQueuedTime","preQueueTime","currentTime","addQueueMeasurement","queueTime","manuallyCompleted","queueMeasurement","existingMeasurements","push","set","measurementArray","delete","startMeasurement","eventCorrelationId","generateId","info","performanceMeasurement","inProgressEvent","eventId","status","PerformanceEventStatus","InProgress","startTimeMs","Date","now","appName","appVersion","cacheEventByCorrelationId","end","event","endMeasurement","discard","discardMeasurements","fields","addFields","increment","incrementFields","measurement","rootEvent","isRoot","queueInfo","totalQueueTime","totalQueueCount","manuallyCompletedCount","getQueueInfo","discardCache","incompleteSubMeasurements","durationMs","flushMeasurement","Math","floor","finalEvent","incompleteSubsCount","forEach","subMeasurement","undefined","round","queuedTimeMs","queuedCount","queuedManuallyCompletedCount","Completed","truncateIntegralFields","emitEvents","counter","hasOwnProperty","isNaN","Number","queueMeasurementForCorrelationId","addPerformanceCallback","callback","callbackId","verbose","removePerformanceCallback","result","events","apply","key"],"sources":["/Users/sarvagyakumar/Desktop/IISC_Project/node_modules/@azure/msal-common/src/telemetry/performance/PerformanceClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ApplicationTelemetry } from \"../../config/ClientConfiguration\";\nimport { Logger } from \"../../logger/Logger\";\nimport {\n    InProgressPerformanceEvent,\n    IPerformanceClient,\n    PerformanceCallbackFunction,\n    QueueMeasurement,\n} from \"./IPerformanceClient\";\nimport { IPerformanceMeasurement } from \"./IPerformanceMeasurement\";\nimport {\n    IntFields,\n    PerformanceEvent,\n    PerformanceEvents,\n    PerformanceEventStatus,\n} from \"./PerformanceEvent\";\n\nexport interface PreQueueEvent {\n    name: PerformanceEvents;\n    time: number;\n}\n\nexport abstract class PerformanceClient implements IPerformanceClient {\n    protected authority: string;\n    protected libraryName: string;\n    protected libraryVersion: string;\n    protected applicationTelemetry: ApplicationTelemetry;\n    protected clientId: string;\n    protected logger: Logger;\n    protected callbacks: Map<string, PerformanceCallbackFunction>;\n\n    /**\n     * Multiple events with the same correlation id.\n     * @protected\n     * @type {Map<string, PerformanceEvent>}\n     */\n    protected eventsByCorrelationId: Map<string, PerformanceEvent>;\n\n    /**\n     * Map of pre-queue times by correlation Id\n     *\n     * @protected\n     * @type {Map<string, PreQueueEvent>}\n     */\n    protected preQueueTimeByCorrelationId: Map<string, PreQueueEvent>;\n\n    /**\n     * Map of queue measurements by correlation Id\n     *\n     * @protected\n     * @type {Map<string, Array<QueueMeasurement>>}\n     */\n    protected queueMeasurements: Map<string, Array<QueueMeasurement>>;\n\n    protected intFields: Set<string>;\n\n    /**\n     * Creates an instance of PerformanceClient,\n     * an abstract class containing core performance telemetry logic.\n     *\n     * @constructor\n     * @param {string} clientId Client ID of the application\n     * @param {string} authority Authority used by the application\n     * @param {Logger} logger Logger used by the application\n     * @param {string} libraryName Name of the library\n     * @param {string} libraryVersion Version of the library\n     * @param {ApplicationTelemetry} applicationTelemetry application name and version\n     * @param {Set<String>} intFields integer fields to be truncated\n     */\n    constructor(\n        clientId: string,\n        authority: string,\n        logger: Logger,\n        libraryName: string,\n        libraryVersion: string,\n        applicationTelemetry: ApplicationTelemetry,\n        intFields?: Set<string>\n    ) {\n        this.authority = authority;\n        this.libraryName = libraryName;\n        this.libraryVersion = libraryVersion;\n        this.applicationTelemetry = applicationTelemetry;\n        this.clientId = clientId;\n        this.logger = logger;\n        this.callbacks = new Map();\n        this.eventsByCorrelationId = new Map();\n        this.queueMeasurements = new Map();\n        this.preQueueTimeByCorrelationId = new Map();\n        this.intFields = intFields || new Set();\n        for (const item of IntFields) {\n            this.intFields.add(item);\n        }\n    }\n\n    /**\n     * Generates and returns a unique id, typically a guid.\n     *\n     * @abstract\n     * @returns {string}\n     */\n    abstract generateId(): string;\n\n    /**\n     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\n     * Note: this function can be changed to abstract at the next major version bump.\n     *\n     * @param {string} measureName\n     * @param {string} correlationId\n     * @returns {IPerformanceMeasurement}\n     */\n    startPerformanceMeasurement(\n        measureName: string, // eslint-disable-line @typescript-eslint/no-unused-vars\n        correlationId: string // eslint-disable-line @typescript-eslint/no-unused-vars\n    ): IPerformanceMeasurement {\n        return {} as IPerformanceMeasurement;\n    }\n\n    /**\n     * Sets pre-queue time by correlation Id\n     *\n     * @abstract\n     * @param {PerformanceEvents} eventName\n     * @param {string} correlationId\n     * @returns\n     */\n    abstract setPreQueueTime(\n        eventName: PerformanceEvents,\n        correlationId?: string\n    ): void;\n\n    /**\n     * Gets map of pre-queue times by correlation Id\n     *\n     * @param {PerformanceEvents} eventName\n     * @param {string} correlationId\n     * @returns {number}\n     */\n    getPreQueueTime(eventName: string, correlationId: string): number | void {\n        const preQueueEvent: PreQueueEvent | undefined =\n            this.preQueueTimeByCorrelationId.get(correlationId);\n\n        if (!preQueueEvent) {\n            this.logger.trace(\n                `PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: ${correlationId}, unable to add queue measurement`\n            );\n            return;\n        } else if (preQueueEvent.name !== eventName) {\n            this.logger.trace(\n                `PerformanceClient.getPreQueueTime: no pre-queue time found for ${eventName}, unable to add queue measurement`\n            );\n            return;\n        }\n\n        return preQueueEvent.time;\n    }\n\n    /**\n     * Calculates the difference between current time and time when function was queued.\n     * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.\n     *\n     * @param {number} preQueueTime\n     * @param {number} currentTime\n     * @returns {number}\n     */\n    calculateQueuedTime(preQueueTime: number, currentTime: number): number {\n        if (preQueueTime < 1) {\n            this.logger.trace(\n                `PerformanceClient: preQueueTime should be a positive integer and not ${preQueueTime}`\n            );\n            return 0;\n        }\n\n        if (currentTime < 1) {\n            this.logger.trace(\n                `PerformanceClient: currentTime should be a positive integer and not ${currentTime}`\n            );\n            return 0;\n        }\n\n        if (currentTime < preQueueTime) {\n            this.logger.trace(\n                \"PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved\"\n            );\n            return 0;\n        }\n\n        return currentTime - preQueueTime;\n    }\n\n    /**\n     * Adds queue measurement time to QueueMeasurements array for given correlation ID.\n     *\n     * @param {PerformanceEvents} eventName\n     * @param {?string} correlationId\n     * @param {?number} queueTime\n     * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\n     * @returns\n     */\n    addQueueMeasurement(\n        eventName: string,\n        correlationId?: string,\n        queueTime?: number,\n        manuallyCompleted?: boolean\n    ): void {\n        if (!correlationId) {\n            this.logger.trace(\n                `PerformanceClient.addQueueMeasurement: correlationId not provided for ${eventName}, cannot add queue measurement`\n            );\n            return;\n        }\n\n        if (queueTime === 0) {\n            // Possible for there to be no queue time after calculation\n            this.logger.trace(\n                `PerformanceClient.addQueueMeasurement: queue time provided for ${eventName} is ${queueTime}`\n            );\n        } else if (!queueTime) {\n            this.logger.trace(\n                `PerformanceClient.addQueueMeasurement: no queue time provided for ${eventName}`\n            );\n            return;\n        }\n\n        const queueMeasurement: QueueMeasurement = {\n            eventName,\n            // Always default queue time to 0 for manually completed (improperly instrumented)\n            queueTime: manuallyCompleted ? 0 : queueTime,\n            manuallyCompleted,\n        };\n\n        // Adds to existing correlation Id if present in queueMeasurements\n        const existingMeasurements = this.queueMeasurements.get(correlationId);\n        if (existingMeasurements) {\n            existingMeasurements.push(queueMeasurement);\n            this.queueMeasurements.set(correlationId, existingMeasurements);\n        } else {\n            // Sets new correlation Id if not present in queueMeasurements\n            this.logger.trace(\n                `PerformanceClient.addQueueMeasurement: adding correlationId ${correlationId} to queue measurements`\n            );\n            const measurementArray = [queueMeasurement];\n            this.queueMeasurements.set(correlationId, measurementArray);\n        }\n        // Delete processed pre-queue event.\n        this.preQueueTimeByCorrelationId.delete(correlationId);\n    }\n\n    /**\n     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\n     *\n     * @param {PerformanceEvents} measureName\n     * @param {?string} [correlationId]\n     * @returns {InProgressPerformanceEvent}\n     */\n    startMeasurement(\n        measureName: string,\n        correlationId?: string\n    ): InProgressPerformanceEvent {\n        // Generate a placeholder correlation if the request does not provide one\n        const eventCorrelationId = correlationId || this.generateId();\n        if (!correlationId) {\n            this.logger.info(\n                `PerformanceClient: No correlation id provided for ${measureName}, generating`,\n                eventCorrelationId\n            );\n        }\n\n        this.logger.trace(\n            `PerformanceClient: Performance measurement started for ${measureName}`,\n            eventCorrelationId\n        );\n        const performanceMeasurement = this.startPerformanceMeasurement(\n            measureName,\n            eventCorrelationId\n        );\n        performanceMeasurement.startMeasurement();\n\n        const inProgressEvent: PerformanceEvent = {\n            eventId: this.generateId(),\n            status: PerformanceEventStatus.InProgress,\n            authority: this.authority,\n            libraryName: this.libraryName,\n            libraryVersion: this.libraryVersion,\n            clientId: this.clientId,\n            name: measureName,\n            startTimeMs: Date.now(),\n            correlationId: eventCorrelationId,\n            appName: this.applicationTelemetry?.appName,\n            appVersion: this.applicationTelemetry?.appVersion,\n        };\n\n        // Store in progress events so they can be discarded if not ended properly\n        this.cacheEventByCorrelationId(inProgressEvent);\n\n        // Return the event and functions the caller can use to properly end/flush the measurement\n        return {\n            end: (\n                event?: Partial<PerformanceEvent>\n            ): PerformanceEvent | null => {\n                return this.endMeasurement(\n                    {\n                        // Initial set of event properties\n                        ...inProgressEvent,\n                        // Properties set when event ends\n                        ...event,\n                    },\n                    performanceMeasurement\n                );\n            },\n            discard: () => {\n                return this.discardMeasurements(inProgressEvent.correlationId);\n            },\n            add: (fields: { [key: string]: {} | undefined }) => {\n                return this.addFields(fields, inProgressEvent.correlationId);\n            },\n            increment: (fields: { [key: string]: number | undefined }) => {\n                return this.incrementFields(\n                    fields,\n                    inProgressEvent.correlationId\n                );\n            },\n            measurement: performanceMeasurement,\n            event: inProgressEvent,\n        };\n    }\n\n    /**\n     * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\n     * as consumers should instead use the function returned by startMeasurement.\n     * Adds a new field named as \"[event name]DurationMs\" for sub-measurements, completes and emits an event\n     * otherwise.\n     *\n     * @param {PerformanceEvent} event\n     * @param {IPerformanceMeasurement} measurement\n     * @returns {(PerformanceEvent | null)}\n     */\n    endMeasurement(\n        event: PerformanceEvent,\n        measurement?: IPerformanceMeasurement\n    ): PerformanceEvent | null {\n        const rootEvent: PerformanceEvent | undefined =\n            this.eventsByCorrelationId.get(event.correlationId);\n        if (!rootEvent) {\n            this.logger.trace(\n                `PerformanceClient: Measurement not found for ${event.eventId}`,\n                event.correlationId\n            );\n            return null;\n        }\n\n        const isRoot = event.eventId === rootEvent.eventId;\n        let queueInfo = {\n            totalQueueTime: 0,\n            totalQueueCount: 0,\n            manuallyCompletedCount: 0,\n        };\n        if (isRoot) {\n            queueInfo = this.getQueueInfo(event.correlationId);\n            this.discardCache(rootEvent.correlationId);\n        } else {\n            rootEvent.incompleteSubMeasurements?.delete(event.eventId);\n        }\n\n        measurement?.endMeasurement();\n        const durationMs = measurement?.flushMeasurement();\n        // null indicates no measurement was taken (e.g. needed performance APIs not present)\n        if (!durationMs) {\n            this.logger.trace(\n                \"PerformanceClient: Performance measurement not taken\",\n                rootEvent.correlationId\n            );\n            return null;\n        }\n\n        this.logger.trace(\n            `PerformanceClient: Performance measurement ended for ${event.name}: ${durationMs} ms`,\n            event.correlationId\n        );\n\n        // Add sub-measurement attribute to root event.\n        if (!isRoot) {\n            rootEvent[event.name + \"DurationMs\"] = Math.floor(durationMs);\n            return { ...rootEvent };\n        }\n\n        let finalEvent: PerformanceEvent = { ...rootEvent, ...event };\n        let incompleteSubsCount: number = 0;\n        // Incomplete sub-measurements are discarded. They are likely an instrumentation bug that should be fixed.\n        finalEvent.incompleteSubMeasurements?.forEach((subMeasurement) => {\n            this.logger.trace(\n                `PerformanceClient: Incomplete submeasurement ${subMeasurement.name} found for ${event.name}`,\n                finalEvent.correlationId\n            );\n            incompleteSubsCount++;\n        });\n        finalEvent.incompleteSubMeasurements = undefined;\n\n        finalEvent = {\n            ...finalEvent,\n            durationMs: Math.round(durationMs),\n            queuedTimeMs: queueInfo.totalQueueTime,\n            queuedCount: queueInfo.totalQueueCount,\n            queuedManuallyCompletedCount: queueInfo.manuallyCompletedCount,\n            status: PerformanceEventStatus.Completed,\n            incompleteSubsCount,\n        };\n        this.truncateIntegralFields(finalEvent);\n        this.emitEvents([finalEvent], event.correlationId);\n\n        return finalEvent;\n    }\n\n    /**\n     * Saves extra information to be emitted when the measurements are flushed\n     * @param fields\n     * @param correlationId\n     */\n    addFields(\n        fields: { [key: string]: {} | undefined },\n        correlationId: string\n    ): void {\n        this.logger.trace(\"PerformanceClient: Updating static fields\");\n        const event = this.eventsByCorrelationId.get(correlationId);\n        if (event) {\n            this.eventsByCorrelationId.set(correlationId, {\n                ...event,\n                ...fields,\n            });\n        } else {\n            this.logger.trace(\n                \"PerformanceClient: Event not found for\",\n                correlationId\n            );\n        }\n    }\n\n    /**\n     * Increment counters to be emitted when the measurements are flushed\n     * @param fields {string[]}\n     * @param correlationId {string} correlation identifier\n     */\n    incrementFields(\n        fields: { [key: string]: number | undefined },\n        correlationId: string\n    ): void {\n        this.logger.trace(\"PerformanceClient: Updating counters\");\n        const event = this.eventsByCorrelationId.get(correlationId);\n        if (event) {\n            for (const counter in fields) {\n                if (!event.hasOwnProperty(counter)) {\n                    event[counter] = 0;\n                } else if (isNaN(Number(event[counter]))) {\n                    return;\n                }\n                event[counter] += fields[counter];\n            }\n        } else {\n            this.logger.trace(\n                \"PerformanceClient: Event not found for\",\n                correlationId\n            );\n        }\n    }\n\n    /**\n     * Upserts event into event cache.\n     * First key is the correlation id, second key is the event id.\n     * Allows for events to be grouped by correlation id,\n     * and to easily allow for properties on them to be updated.\n     *\n     * @private\n     * @param {PerformanceEvent} event\n     */\n    protected cacheEventByCorrelationId(event: PerformanceEvent): void {\n        const rootEvent = this.eventsByCorrelationId.get(event.correlationId);\n        if (rootEvent) {\n            this.logger.trace(\n                `PerformanceClient: Performance measurement for ${event.name} added/updated`,\n                event.correlationId\n            );\n            rootEvent.incompleteSubMeasurements =\n                rootEvent.incompleteSubMeasurements || new Map();\n            rootEvent.incompleteSubMeasurements.set(event.eventId, {\n                name: event.name,\n                startTimeMs: event.startTimeMs,\n            });\n        } else {\n            this.logger.trace(\n                `PerformanceClient: Performance measurement for ${event.name} started`,\n                event.correlationId\n            );\n            this.eventsByCorrelationId.set(event.correlationId, { ...event });\n        }\n    }\n\n    private getQueueInfo(correlationId: string): {\n        totalQueueTime: number;\n        totalQueueCount: number;\n        manuallyCompletedCount: number;\n    } {\n        const queueMeasurementForCorrelationId =\n            this.queueMeasurements.get(correlationId);\n        if (!queueMeasurementForCorrelationId) {\n            this.logger.trace(\n                `PerformanceClient: no queue measurements found for for correlationId: ${correlationId}`\n            );\n        }\n\n        let totalQueueTime = 0;\n        let totalQueueCount = 0;\n        let manuallyCompletedCount = 0;\n        queueMeasurementForCorrelationId?.forEach((measurement) => {\n            totalQueueTime += measurement.queueTime;\n            totalQueueCount++;\n            manuallyCompletedCount += measurement.manuallyCompleted ? 1 : 0;\n        });\n\n        return {\n            totalQueueTime,\n            totalQueueCount,\n            manuallyCompletedCount,\n        };\n    }\n\n    /**\n     * Removes measurements for a given correlation id.\n     *\n     * @param {string} correlationId\n     */\n    discardMeasurements(correlationId: string): void {\n        this.logger.trace(\n            \"PerformanceClient: Performance measurements discarded\",\n            correlationId\n        );\n        this.eventsByCorrelationId.delete(correlationId);\n    }\n\n    /**\n     * Removes cache for a given correlation id.\n     *\n     * @param {string} correlationId correlation identifier\n     */\n    private discardCache(correlationId: string): void {\n        this.discardMeasurements(correlationId);\n\n        this.logger.trace(\n            \"PerformanceClient: QueueMeasurements discarded\",\n            correlationId\n        );\n        this.queueMeasurements.delete(correlationId);\n\n        this.logger.trace(\n            \"PerformanceClient: Pre-queue times discarded\",\n            correlationId\n        );\n        this.preQueueTimeByCorrelationId.delete(correlationId);\n    }\n\n    /**\n     * Registers a callback function to receive performance events.\n     *\n     * @param {PerformanceCallbackFunction} callback\n     * @returns {string}\n     */\n    addPerformanceCallback(callback: PerformanceCallbackFunction): string {\n        const callbackId = this.generateId();\n        this.callbacks.set(callbackId, callback);\n        this.logger.verbose(\n            `PerformanceClient: Performance callback registered with id: ${callbackId}`\n        );\n\n        return callbackId;\n    }\n\n    /**\n     * Removes a callback registered with addPerformanceCallback.\n     *\n     * @param {string} callbackId\n     * @returns {boolean}\n     */\n    removePerformanceCallback(callbackId: string): boolean {\n        const result = this.callbacks.delete(callbackId);\n\n        if (result) {\n            this.logger.verbose(\n                `PerformanceClient: Performance callback ${callbackId} removed.`\n            );\n        } else {\n            this.logger.verbose(\n                `PerformanceClient: Performance callback ${callbackId} not removed.`\n            );\n        }\n\n        return result;\n    }\n\n    /**\n     * Emits events to all registered callbacks.\n     *\n     * @param {PerformanceEvent[]} events\n     * @param {?string} [correlationId]\n     */\n    emitEvents(events: PerformanceEvent[], correlationId: string): void {\n        this.logger.verbose(\n            \"PerformanceClient: Emitting performance events\",\n            correlationId\n        );\n\n        this.callbacks.forEach(\n            (callback: PerformanceCallbackFunction, callbackId: string) => {\n                this.logger.trace(\n                    `PerformanceClient: Emitting event to callback ${callbackId}`,\n                    correlationId\n                );\n                callback.apply(null, [events]);\n            }\n        );\n    }\n\n    /**\n     * Enforce truncation of integral fields in performance event.\n     * @param {PerformanceEvent} event performance event to update.\n     * @param {Set<string>} intFields integral fields.\n     */\n    private truncateIntegralFields(event: PerformanceEvent): void {\n        this.intFields.forEach((key) => {\n            if (key in event && typeof event[key] === \"number\") {\n                event[key] = Math.floor(event[key]);\n            }\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}